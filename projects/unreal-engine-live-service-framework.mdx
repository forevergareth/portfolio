---
title: "Unreal Engine Live-Service Framework"
publishedAt: "2025-10-20"
summary: "Full-stack live-service framework featuring a distributed microservice backend in Go and a modular Unreal Engine client with integrated networking and UI systems."
image: "/img/unreal-engine-live-service-framework/r3-dev-00.png"
platform: "Windows, Linux"
tools: ["Unreal Engine", "Golang", "Steamworks", "Kubernetes", "Docker", "PostgreSQL", "Redis", "Stripe API", "Jenkins", "CommonUI", "Gameplay Ability System"]
teamSize: "Solo"
---

<div style="width: 100%; margin-bottom: 2rem;">
  <iframe
    style="width: 100%; height: 500px; border-radius: 0.5rem; border: none;"
    src="https://www.youtube.com/embed/aSQL-0eaqtM?si=EfoeOxp7GSkbCSns"
    title="Unreal Engine Live Service Framework Demo"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>


## Overview
To support a global-scale, multiplayer live-service title, I architected and implemented a **robust, scalable platform** designed to handle the rigorous demands of modern online gaming. The core of this project is a distributed backend built on a **microservice architecture using Go**, engineered to decouple critical game systems for high avaliability and maintainability.

This platform provides a seamless, persistent experience for players, managing everything from cross-platform authentication and authoritative progression to complex inventory management and real-money monetization. The entire infrastructure is **containerized with Docker and orchestrated by Kubernetes**, ensuring a production-grade, resilient environment capable of auto-scaling to meet player demand.

---

## Key Technical Challenges & Solutions

### 1. Managing Distributed State at Scale
**Challenge**: Ensuring data consistency and low latency for player data (inventory, stats) across multiple independent services without creating bottlenecks. <br />
**Solution**: Implemented a **stateless microservice architecture** where services delegate state persistence to dedicated databases.
- **Redis** is used for high-frequency, ephemeral data like session caching, matchmaking tickets, and presence.
- **PostgreSQL** handles long-term persistent data (accounts, inventory) with strict transactional integrity.
- **Result**: Services can scale horizontally independently. A failure in the Store service doesn't affect active Game Sessions.

### 2. Real-Time Latency vs. Reliability
**Challenge**: Different game features have conflicting networking requirements. Matchmaking needs reliability, while presence and notifications need speed. <br />
**Solution**: A **hybrid networking approach**:
- **TCP (Go)**: Used for critical, stateful communication like Party Management, Matchmaking notifications, and Chat, ensuring guaranteed delivery.
- **REST (Go)**: Used for non-time-critical, transactional operations like Inventory retrieval and Store purchases.
- **Result**: Optimized bandwidth usage and responsiveness by choosing the right protocol for the right job.

---

## Core Features & Technical Breakdown

### 1. Live-Service Microservice Architecture

**Goal**: Create a scalable, maintainable backend by decoupling core domains into independent services.

**Implementation**:
I developed a suite of high-performance microservices using **Go**. Inter-service communication is handled via gRPC and RabbitMQ Message Bus for asynchronous events, ensuring loose coupling.

![Gameplay Screenshot](/img/unreal-engine-live-service-framework/r3-dev-00.png)

#### Service Ecosystem:
- **Gateway Service**: Single entry point for client TCP connections, handles async message routing and persistent connection management.
- **Auth Service**: Manages identity, JWT issuance, and integration with third-party providers (Steam).
- **Player Service**: Handles persistent player profiles, stats, and loadouts.
- **Session Service**: Tracks active player sessions and manages dedicated server lifecycles.
- **Matchmaker Service**: Implements skill-based matchmaking logic and lobby management.
- **Store Service**: Manages catalog rotation, virtual currency, and payment processing.
- **Analytics Service**: Ingests and processes telemetry data for game balancing and business intelligence.

---

### 2. DevOps & Infrastructure

**Goal**: Establish a professional-grade development and deployment pipeline to ensure code quality and rapid iteration.

**Implementation**:
- **Docker Containerization**: Every service and database (PostgreSQL, Redis) is containerized, guaranteeing that the development environment mirrors production exactly. This eliminates "it works on my machine" issues.
- **Kubernetes Orchestration**: Deployed on a cluster of VPS nodes, Kubernetes handles service discovery, load balancing, and self-healing (restarting failed pods automatically), testing locally with Minikube.
- **CI/CD with Jenkins**: Automated pipelines trigger on git commits to run tests, build Docker images, and deploy to staging environments. This allows for safe, rapid deployment of new features and hotfixes.

![Gameplay Screenshot](/img/unreal-engine-live-service-framework/r3-dev-01.png)

---

### 3. Gameplay Features (Backend-Authoritative)

**Goal**: Design secure, engaging metagame loops that drive long-term retention.

**Implementation**:
All critical logic is **server-authoritative** to prevent cheating and ensure fairness.

![Gameplay Screenshot](/img/unreal-engine-live-service-framework/r3-dev-03.png)

#### Progression System
- **XP & Leveling**: Match results are sent to the backend, which validates the data and calculates XP gains.
- **Rewards**: Level-ups trigger server-side reward distribution (items, currency), ensuring players actually earned their loot.

#### Inventory & Equipment
- **Flexible Itemization**: A robust inventory system supporting diverse item types (Weapons, Skins, Charms).
- **Loadouts**: Players can configure persistent loadouts that are stored server-side and synced to any device.
- **State Management**: Handles complex logic like item stacking and uniqueness constraints.

#### Metagame & Monetization
- **Virtual Economy**: Secure management of soft (earned) and hard (purchased) currency balances.
- **Stripe Integration**: Direct integration with Stripe API for real-money transactions, handling webhooks for secure fulfillment and audit logging.
- **Store Rotation**: The backend controls the active store catalog, allowing for dynamic updates and limited-time offers without client patches.

---

### 4. Cross-Platform & Unified Accounts

**Goal**: Enable a seamless "play anywhere" experience.

**Implementation**:
- **Unified Identity**: The **Auth Service** links multiple platform identities (Steam ID, Email/Password) to a single internal User ID. This allows players to switch platforms while keeping all progression and items.
- **Steam Integration**: Utilizes Steamworks API for "click-to-login" functionality, validating session tickets server-side for secure authentication.
- **Custom Auth**: A parallel JWT-based auth flow for non-Steam platforms, using bcrypt for password security and refresh tokens for long-lived sessions.

![Gameplay Screenshot](/img/unreal-engine-live-service-framework/r3-dev-03.png)

---

### 5. Unreal Engine Client Architecture

**Goal**: Build a modular, maintainable game client that can easily consume backend services.

**Implementation**:

#### Modular Design
The client is architected into distinct modules to enforce separation of concerns:
- **R3OnlineServices**: Handles all HTTP/TCP communication with the backend.
- **R3**: Core gameplay logic.

#### CommonUI & UX
Leveraged Epic's **CommonUI** plugin to create a rich, multi-platform user interface. This ensures consistent input routing (Gamepad/KBM) and a unified visual style across menus.

#### Data-Driven Design
Extensive use of **DataAssets** for configuration (e.g., Item Definitions, UI Styles, API Endpoints). This allows designers to tweak game values and add new content via the Editor without modifying C++ code or requiring a recompile, significantly speeding up iteration time.

#### Gameplay Ability System (GAS) Readiness
The architecture is designed with GAS in mind for future character abilities. Player attributes (Health, Stamina) are structured to be modular and replicable, ensuring seamless integration when the ability system is fully brought online.

---

### 6. Real-Time Communication

**Goal**: Establish a low-latency control channel for live game events.

**Implementation**:
- **TCP Sockets**: Used for handling Purchase and Matchmaking Notifications. TCP ensures that these critical messages are never lost.
- **REST**: Used for "cold" data fetching profiles, inventory, store catalogs, and progression metadata.

![Gameplay Screenshot](/img/unreal-engine-live-service-framework/r3-dev-03.png)

---

*This project represents a comprehensive exploration of full-stack game development, bridging the gap between high-fidelity gameplay and scalable cloud infrastructure.*
